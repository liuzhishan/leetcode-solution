题目链接: [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

题目描述

```
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
```

## 拆解子问题与循环不变式

我们首先手动尝试几个示例:
- `s = ""`, `p = ""`, 显然匹配。
- `s = ""`, `p = *`, 也匹配。
- `s = ""`, `p = ".*"`, 显然匹配。
- `s = "a"`, `p = ""`, 显然不匹配。
- `s = "a"`, `p = "."`, 显然匹配。
- `s = "aa"`, `p = "a"`, 显然不匹配。

我们发现，由于 `p` 中 `*` 的存在, `s` 和 `p` 的长度不一定相等, 当前的匹配情况也依赖于前面的子串匹配的情况。

题目输入有两个字符串, 可以看做是两个字符数组, 可以以长度为维度来拆解子问题。

循环不变式: 假设 `n = len(s)`, `m = len(p)`, 则子问题为 `s[0:i]` 和 `p[0:j]` 是否匹配, i 和 j 的取值范围为 `[0, n]` 和 `[0, m]`, `dp[i][j]` 表示 `s[0:i]` 和 `p[0:j]` 是否匹配。显然, `dp[0][0] = True`。
考虑 `dp[i][j]` 的情况, `i` 范围为 `[0, n]`, `j` 范围为 `[1, m]`。
- 如果 `p[j - 1] == '*'`, `*` 可以和之前一个字符组合为 `0` 个或多个。
  - 考虑 `0` 个的情况, 则 `dp[i][j] |= dp[i][j - 2]`。
  - 考虑 `1` 个或多个的情况, 因为多个又可以进一步分成多次一个，从而继续递归子问题，因为可以考虑一个的情况即可, 此时需要考虑 `p[j - 2]` 是否为 `.`。
    - 如果 `p[j - 2] == '.'`, 则 `dp[i][j] |= dp[i - 1][j]`。
    - 如果 `p[j - 2] != '.'`, 则 `dp[i][j] |= dp[i - 1][j]` 并且需要满足 `s[i - 1] == p[j - 2]`。
- 如果 `p[j - 1] != '*'`, 则 `dp[i][j] = dp[i - 1][j - 1]` 并且需要满足 `s[i - 1] == p[j - 1]` 或者 `p[j - 1] == '.'`。

根据以上思路则可以实现完整的代码，最后返回 `dp[n][m]` 即可。

## 代码实现

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        n = len(s)
        m = len(p)

        dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]

        dp[0][0] = True

        for i in range(n + 1):
            for j in range(1, m + 1):
                if p[j - 1] == '*':
                    if j - 2 >= 0:
                        dp[i][j] |= dp[i][j - 2]
                    if i - 1 >= 0 and j - 2 >= 0 and p[j - 2] == '.':
                        dp[i][j] |= dp[i - 1][j]
                    elif i - 1 >= 0 and j - 2 >= 0 and p[j - 2] != '.':
                        dp[i][j] |= dp[i - 1][j] and s[i - 1] == p[j - 2]
                    else:
                        pass
                else:
                    if i - 1 >= 0 and j - 1 >= 0:
                        dp[i][j] |= dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')
                    elif i - 1 >= 0:
                        dp[i][j] |= dp[i - 1][j]
                    else:
                        pass

        return dp[n][m]
```