# 引言

本系列文章是关于 LeetCode 题解的系列文章, 核心是一个系统化的解题思路: 拆解子问题与循环不变式。

对应的题解代码路径都在本仓库 [src/solution](https://github.com/liuzhishan/leetcode-solution/tree/main/src/solution) 目录下。

我们通常在解算法题的时候，会习惯性的将题目归类到不同的模板中，如二分、搜索、动态规划等, 这样如果遇到类似的问题，我们
很快就能根据模板写出答案。但是，如果遇到一个没有见过的题目，我们可能就无从下手了。

因此，本系列文章介绍一种系统化的解题思路: 拆解子问题与循环不变式, 在大家遇到一道题目时，可以根据这一思路系统的对题目
一步一步进行拆解，从而找到问题的答案。其核心思想是将问题拆解为更小的子问题，根据子问题的解来构造当前问题的解。而循环不变式
则是指循环执行过程中始终成立的命题，用来在具体实现过程中保证代码的正确性。

实际解题过程中，这两者的关系也会比较模糊，并不需要严格的区分。

**注意**: 我们的目的不是拿到一道题目立刻就能想到用什么模板, 而应该是头脑一片空白, 没有任何预设的模板，然后通过系统化
的思路一步一步分析，最终得到答案。

下面再稍微展开介绍一下。

## 拆解子问题

如果我们仔细观察所有的算法题，可以发现每个题目的实现都至少会包含一个循环或者递归，也可能会有多个，而每一层循环或者递归，
都必定能够准确地对应到原问题的一个子问题。整体程序所描述的就是子问题之间的关系。因此，如果我们反过来思考，在写代码之前，
想办法将问题拆解为更小的子问题，然后用子问题的解来构造当前问题的解，就能够最终解决这个问题。如何拆解子问题则需要在保证
完备性的基础上，根据问题的特点来进行分析。一般可以先手动尝试几个示例，清楚题目具体要求，然后尝试从不同的角度来减小问题
的规模，从而达到拆解子问题的目的。比如对于数组, 减一个元素、二分、从两边往中间收缩等，都是减小规模的思路。

**注意1**: 这里有一个非常重要的点，即当我们在考虑当前问题时，我们不需要知道之前的子问题的解是如何得到的，我们只需要知道
子问题的解已经存在，并且是正确的，然后想办法用这些解来构造当前问题的解。

**注意2**: 在拆解子问题时，我们需要保证子问题不遗漏。


## 循环不变式

循环不变式是指循环执行前后始终成立的命题，有点类似数学归纳法，主要包括三个阶段:
- 初始化: 循环第一次迭代前成立。
- 保持: 循环的每一轮迭代开始前成立，迭代结束后仍然成立。
- 终止: 循环结束时成立。

循环不变式是一个非常重要的概念，可以说整本 <<算法导论>> 都在翻来覆去的用各种问题来解释循环不变式。

我们用斐波那契数列的递归实现来介绍一下循环不变式。

```python
def fib(n: int) -> int:
    if n <= 1:
        return n

    a = 0
    b = 1

    for i in range(2, n + 1):
        a, b = b, a + b

    return b
```

我们用循环不变式来分析一下这个循环。

循环不变式: `b` 表示当前斐波那契数，`a` 表示前一个斐波那契数。
- 初始化: `i` 从 `2` 开始，循环开始前 `i = 1`, `a = 0`, `b = 1` 成立。
- 保持: 当循环变量为 `2` 到 `i - 1` 时循环不变式都成立，则 `a = fib(i - 2)`, `b = fib(i - 1)`，当 `i` 轮迭代后，`a = fib(i - 1)`, `b = fib(i - 2) + fib(i - 1) = fib(i)`，则迭代结束后依然成立。
- 终止: 当 `i = n` 时，`a = fib(n - 1)`，`b = fib(n)`。

可以看到，循环不变式在每一轮迭代开始前都成立，并且在循环结束后仍然成立。

循环不变式的初始化和终止逻辑一般都比较简单, 难点在与保持。为了节省时间, 我们后续的讲解都将重点放在保持阶段的逻辑上，忽略初始化和终止。

## 代码实现的一些细节

算法题比较关注时间与空间复杂度，一般不会有太复杂的数据结构，常用的数据结构主要是 `list`、`dict`、`ListNode`、`TreeNode` 等。栈和堆可以直接用
`list` 来实现。注意如下一些细节基本能覆盖绝大部分情况，从而避免程序出现 coredump 等异常情况。
- 访问 `list` 元素时，必须先判断索引是否越界。如 `if 0 <= i < len(arr): ...`。
- 访问 `dict` 元素时，必须先判断 key 是否存在。如 `if key in d: ...`。
- 使用 `list` 实现栈与队列时，必须先判断是否为空。如 `if len(stack) > 0: ...`。
- 使用 `ListNode` 进行链表操作时，必须先判断节点是否为空。如 `if head != None: ...`。
- 使用 `TreeNode` 进行树操作时，必须先判断节点是否为空。如 `if root != None: ...`。

## 示例

下面结合几个具体的题目，来介绍一下如何应用这一思路来解决问题。

- 示例: [3. 无重复字符的最长子串](solution/03_longest_substring_without_repeating_characters.md)
- 示例: [28. 找出字符串中第一个匹配项的下标](solution/28_find_the_index_of_the_first_occurrence_in_a_string.md)
- 示例: [84. 柱状图中最大的矩形](solution/84_largest_rectangle_in_histogram.md)