# 引言

本系列文章是关于 LeetCode 题解的系列文章, 核心是一个系统化的解题思路: 拆解子问题与循环不变式。

我们通常在解算法题的时候，会习惯性的将题目归类到不同的模板中，如二分、搜索、动态规划等, 这样如果遇到类似的问题，我们
很快就能根据模板写出答案。但是，如果遇到一个没有见过的题目，我们可能就无从下手了。

因此，本系列文章介绍一种系统化的解题思路: 拆解子问题与循环不变式, 在大家遇到一道题目时，可以根据这一思路系统的对题目
一步一步进行拆解，从而找到问题的答案。其核心思想是将问题拆解为更小的子问题，根据子问题的解来构造当前问题的解。而循环不变式
则是指循环执行过程中始终成立的命题，用来在具体实现过程中保证代码的正确性。

实际解题过程中，这两者的关系也会比较模糊，并不需要严格的区分。

**注意**: 我们的目的不是拿到一道题目立刻就能想到用什么模板, 而应该是头脑一片空白, 没有任何预设的模板，而是通过系统化
的思路一步一步分析，最终得到答案。

下面再稍微展开介绍一下。

## 拆解子问题

如果我们仔细观察所有的算法题，可以发现每个题目的实现都至少会包含一个循环或者递归，也可能会有多个，而每一层循环或者递归，
都必定能够准确地对应到原问题的一个子问题。整体程序所描述的就是子问题之间的关系。因此，如果我们反过来思考，在写代码之前，
想办法将问题拆解为更小的子问题，然后用子问题的解来构造当前问题的解，就能够最终解决这个问题。如何拆解子问题则需要在保证
完备性的基础上，根据问题的特点来进行分析。一般可以先手动尝试几个示例，清楚题目具体要求，然后尝试从不同的角度来减小问题
的规模，从而达到拆解子问题的目的。

**注意**: 这里有一个非常重要的点，即当我们在考虑当前问题时，我们不需要知道之前的子问题的解是如何得到的，我们只需要知道
子问题的解已经存在，并且是正确的，然后想办法用这些解来构造当前问题的解。

## 循环不变式

循环不变式是指循环执行前后始终成立的命题，有点类似数学归纳法，主要包括三个阶段:
- 初始化: 循环第一次迭代前成立。
- 保持: 循环的每一轮迭代开始前成立，迭代结束后仍然成立。
- 终止: 循环结束时成立。

循环不变式是一个非常重要的概念，可以说整本 <<算法导论>> 都在翻来覆去的用各种问题来解释循环不变式。

我们用斐波那契数列的递归实现来介绍一下循环不变式。

```python
def fib(n: int) -> int:
    if n <= 1:
        return n

    a = 0
    b = 1

    for i in range(2, n + 1):
        a, b = b, a + b

    return b
```

我们用循环不变式来分析一下这个循环。

循环不变式: `b` 表示当前斐波那契数，`a` 表示前一个斐波那契数。
- 初始化: `i` 从 `2` 开始，循环开始前 `i = 1`, `a = 0`, `b = 1` 成立。
- 保持: 当循环变量为 `2` 到 `i - 1` 时循环不变式都成立，则 `a = fib(i - 2)`, `b = fib(i - 1)`，当 `i` 轮迭代后，`a = fib(i - 1)`, `b = fib(i - 2) + fib(i - 1) = fib(i)`，则迭代结束后依然成立。
- 终止: 当 `i = n` 时，`a = fib(n - 1)`，`b = fib(n)`。

可以看到，循环不变式在每一轮迭代开始前都成立，并且在循环结束后仍然成立。

## 代码实现的一些细节

代码实现方面也有一些细节需要注意。


## 示例

下面结合几个具体的题目，来介绍一下如何应用这一思路来解决问题。

### 无重复字符的最长子串

题目链接: [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)



### 找出字符串中第一个匹配项的下标

题目链接: [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)


### 柱状图中最大的矩形


题目链接: [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)









